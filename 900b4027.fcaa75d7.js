(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{161:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return u}));n(51),n(24),n(19),n(20),n(52),n(0);var a=n(196);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var i={id:"hello-world",title:"Hello World!",sidebar_label:"Hello World!"},o=[],l={rightToc:o},c="wrapper";function u(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(c,r({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/neon-bindings/examples/tree/master/thread-count"}),"Examples")),Object(a.b)("p",null,"This guide will walk you through writing, building, and running your first Neon project. We'll try to walk you through each step carefully, but if you want to skip ahead, you can always go straight to the ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/neon-bindings/examples/tree/master/thread-count"}),"full demo")," in the examples repository."),Object(a.b)("p",null,"Our first project will be a tiny module that returns a number indicating how much hardware multithreading the current machine supports. If you're not familiar with multithreading, don't panic! We'll be using ",Object(a.b)("a",r({parentName:"p"},{href:"https://seanmonstar.com/"}),"Sean McArthur"),"'s ",Object(a.b)("a",r({parentName:"p"},{href:"https://crates.io/crates/num_cpus"}),"num_cpus")," library to do all the heavy lifting for us, and we'll just return the number it gives us."),Object(a.b)("p",null,"But even this simple example already demonstrates some of Neon's usefulness: Rust's ",Object(a.b)("a",r({parentName:"p"},{href:"https://crates.io/"}),"crate ecosystem")," is younger than npm but growing quickly and already full of useful and unique libraries. A library like ",Object(a.b)("inlineCode",{parentName:"p"},"num_cpus")," could be useful, for example, as a hint for tuning the size of a ",Object(a.b)("a",r({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers"}),"Web Worker")," pool in an ",Object(a.b)("a",r({parentName:"p"},{href:"../electron-apps/"}),"Electron app"),"."),Object(a.b)("h1",{id:"creating-a-new-project"},"Creating a New Project"),Object(a.b)("p",null,"The first thing we have to do is create our new ",Object(a.b)("inlineCode",{parentName:"p"},"thread-count")," Neon project:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-shell"}),"neon new thread-count\n")),Object(a.b)("p",null,"This will ask us a series of questions similar to the ones asked by ",Object(a.b)("inlineCode",{parentName:"p"},"npm new"),". When it completes, the tool will have created a ",Object(a.b)("inlineCode",{parentName:"p"},"thread-count")," directory with the following layout:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-text"}),"thread-count/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 lib/\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 native/\n\u2502   \u251c\u2500\u2500 Cargo.toml\n\u2502   \u2514\u2500\u2500 src/\n\u2502       \u2514\u2500\u2500 lib.rs\n\u2514\u2500\u2500 package.json\n")),Object(a.b)("p",null,"The first thing to notice about this layout is that ",Object(a.b)("strong",{parentName:"p"},"a Neon project is a Node package"),". In other words, the way to think of a Neon project is:"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Node on the outside, Rust on the inside.")),Object(a.b)("p",null,"The front-end of a Neon package is a pure JavaScript module (",Object(a.b)("inlineCode",{parentName:"p"},"lib/index.js"),", by default), and the back-end is a native library implemented as a Rust crate. The Rust crate lives in the ",Object(a.b)("inlineCode",{parentName:"p"},"native/")," subdirectory of the project."),Object(a.b)("h1",{id:"building-and-running"},"Building and Running"),Object(a.b)("p",null,"We haven't yet implemented anything, but just to see that ",Object(a.b)("inlineCode",{parentName:"p"},"neon new")," produced a complete, minimal Neon project, let's try building it:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-shell"}),"neon build --release\n")),Object(a.b)("p",null,"The build process generates a handful of files that you don't need to work with directly:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"native/index.node"),": the native module itself, which is loaded by ",Object(a.b)("inlineCode",{parentName:"li"},"lib/index.js"),"."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"native/target")," and ",Object(a.b)("inlineCode",{parentName:"li"},"native/artifacts.json"),": cached build results, which makes rebuilds faster.")),Object(a.b)("p",null,"An easy way to clean up build artifacts is to run:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-shell"}),"neon clean\n")),Object(a.b)("p",null,"Once we've built the project, we can try running it:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-shell"}),"node\n> require('.')\nhello node\n{}\n")),Object(a.b)("h1",{id:"adding-a-rust-dependency"},"Adding a Rust Dependency"),Object(a.b)("p",null,"Let's add a Rust dependency on the ",Object(a.b)("a",r({parentName:"p"},{href:"https://crates.io/crates/num_cpus"}),"num_cpus")," crate. In ",Object(a.b)("inlineCode",{parentName:"p"},"native/Cargo.toml"),", under the ",Object(a.b)("inlineCode",{parentName:"p"},"[dependencies]")," section, add the following line:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-toml"}),'num_cpus = "1.4.0"\n')),Object(a.b)("p",null,"This tells Cargo, Rust's build tool, to fetch a version of the ",Object(a.b)("inlineCode",{parentName:"p"},"num_cpus")," crate that is semver-compatible with ",Object(a.b)("inlineCode",{parentName:"p"},"1.4.0"),". (The ",Object(a.b)("inlineCode",{parentName:"p"},"package.json")," equivalent would be ",Object(a.b)("inlineCode",{parentName:"p"},'"num_cpus": "^1.4.0"'),".)"),Object(a.b)("h1",{id:"implementing-our-function"},"Implementing our Function"),Object(a.b)("p",null,"Now let's edit the Rust code to make use of the new dependency. First we have to declare the use of the the ",Object(a.b)("inlineCode",{parentName:"p"},"num_cpus")," crate:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),"extern crate num_cpus;\n")),Object(a.b)("p",null,"Next we can replace the sample ",Object(a.b)("inlineCode",{parentName:"p"},"hello")," function that was generated by ",Object(a.b)("inlineCode",{parentName:"p"},"neon new")," with the function we actually want. Instead of returning a string, our function should return a JavaScript number. So we'll use ",Object(a.b)("a",r({parentName:"p"},{href:"https://neon-bindings.com/api/neon/types/struct.jsnumber"}),Object(a.b)("inlineCode",{parentName:"a"},"cx.number()"))," helper. Since ",Object(a.b)("inlineCode",{parentName:"p"},"cx.number()")," expects a Rust ",Object(a.b)("a",r({parentName:"p"},{href:"https://doc.rust-lang.org/std/primitive.f64.html"}),Object(a.b)("inlineCode",{parentName:"a"},"f64"))," (i.e., a 64-bit floating-point number), and ",Object(a.b)("a",r({parentName:"p"},{href:"https://docs.rs/num_cpus/1.4.0/num_cpus/fn.get.html"}),Object(a.b)("inlineCode",{parentName:"a"},"num_cpus::get()"))," returns a ",Object(a.b)("a",r({parentName:"p"},{href:"https://doc.rust-lang.org/std/primitive.usize.html"}),Object(a.b)("inlineCode",{parentName:"a"},"usize"))," (i.e., a pointer-sized integer), we'll use Rust's",Object(a.b)("inlineCode",{parentName:"p"},"as")," operator to cast to convert the integer to floating-point:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),"use neon::prelude::*;\n\nfn thread_count(mut cx: FunctionContext) -> JsResult<JsNumber> {\n    Ok(cx.number(num_cpus::get() as f64))\n}\n")),Object(a.b)("p",null,"A few more things to note about this code:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"The ",Object(a.b)("inlineCode",{parentName:"li"},"cx")," argument to ",Object(a.b)("inlineCode",{parentName:"li"},"thread_count"),": this contains information about the function call, such as the arguments and the value of ",Object(a.b)("inlineCode",{parentName:"li"},"this"),"."),Object(a.b)("li",{parentName:"ul"},"The ",Object(a.b)("a",r({parentName:"li"},{href:"https://neon-bindings.com/api/neon/result/type.jsresult"}),Object(a.b)("inlineCode",{parentName:"a"},"JsResult"))," output type: this is a Rust ",Object(a.b)("a",r({parentName:"li"},{href:"https://doc.rust-lang.org/std/result/enum.Result.html"}),Object(a.b)("inlineCode",{parentName:"a"},"Result"))," type that indicates whether the function returned (",Object(a.b)("inlineCode",{parentName:"li"},"Ok"),") or threw a JavaScript exception (",Object(a.b)("inlineCode",{parentName:"li"},"Err"),"). You can learn more in the ",Object(a.b)("a",r({parentName:"li"},{href:"../handling-errors"}),"Handling Errors")," guide. It also tracks the lifetime of the returned ",Object(a.b)("em",{parentName:"li"},"handle"),". You can read more about handles in the ",Object(a.b)("a",r({parentName:"li"},{href:"../handles-and-memory/"}),"Handles and Memory")," guide."),Object(a.b)("li",{parentName:"ul"},"The ",Object(a.b)("inlineCode",{parentName:"li"},"cx.number()")," function tells the JavaScript garbage collector that we need to keep the value we allocate alive long enough to return it to the caller of ",Object(a.b)("inlineCode",{parentName:"li"},"thread_count"),". You can learn more about memory management in the ",Object(a.b)("a",r({parentName:"li"},{href:"../handles-and-memory/"}),"Handles and Memory")," guide.")),Object(a.b)("p",null,"Finally, we'll modify the code that ",Object(a.b)("inlineCode",{parentName:"p"},"neon new"),' created for us to set up the module exports with this function instead of the initial "hello world" function it created for us:'),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),'register_module!(mut m, {\n    m.export_function("threadCount", thread_count)\n});\n')),Object(a.b)("p",null,"This tells Neon to initialize the module when it's first loaded by creating a JavaScript function implemented with the ",Object(a.b)("inlineCode",{parentName:"p"},"thread_count")," function we defined above and exporting it as a module property named ",Object(a.b)("inlineCode",{parentName:"p"},'"threadCount"'),"."),Object(a.b)("p",null,"You can see the full ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/neon-bindings/examples/blob/master/thread-count/native/src/lib.rs"}),Object(a.b)("inlineCode",{parentName:"a"},"lib.rs"))," file in the examples repository."),Object(a.b)("h1",{id:"exporting-our-function"},"Exporting our Function"),Object(a.b)("p",null,"Now that the Rust code is implemented, all we have left to do is export it from the project's public module in ",Object(a.b)("inlineCode",{parentName:"p"},"lib/index.js"),". The native module exported a ",Object(a.b)("inlineCode",{parentName:"p"},"threadCount")," property, so we'll just make that function our entire public module:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"const addon = require('../native');\n\nmodule.exports = addon.threadCount;\n")),Object(a.b)("h1",{id:"try-it-out"},"Try it Out!"),Object(a.b)("p",null,"Now we should be able to rebuild the project with ",Object(a.b)("inlineCode",{parentName:"p"},"neon build --release")," again:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-shell"}),"neon build --release\n")),Object(a.b)("p",null,"This will create a release build for us. Assuming we didn't make any mistakes, we can test out our new Neon module at the Node console from the root of our project directory:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-shell"}),"node\n> var threadCount = require('.')\n> threadCount()\n4\n")),Object(a.b)("p",null,"Keep in mind that the result of calling ",Object(a.b)("inlineCode",{parentName:"p"},"threadCount()")," will vary based on the machine you run this demo on\u2014by design!"))}u.isMDXComponent=!0},196:function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return p}));var a=n(0),r=n.n(a),i=r.a.createContext({}),o=function(e){var t=r.a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},l=function(e){var t=o(e.components);return r.a.createElement(i.Provider,{value:t},e.children)};var c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}(e,["components","mdxType","originalType","parentName"]),b=o(n),p=a,s=b[l+"."+p]||b[p]||u[p]||i;return n?r.a.createElement(s,Object.assign({},{ref:t},c,{components:n})):r.a.createElement(s,Object.assign({},{ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=b;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[c]="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);