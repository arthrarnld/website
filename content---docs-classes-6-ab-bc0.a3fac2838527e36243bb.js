(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{167:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"rightToc",(function(){return i})),t.d(n,"default",(function(){return c}));t(58),t(31),t(21),t(22),t(59),t(0);var a=t(217);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var s={id:"classes",title:"Classes",sidebar_label:"Classes"},i=[{value:"Basics",id:"basics",children:[{value:"Defining the constructor",id:"defining-the-constructor",children:[]},{value:"Adding Methods",id:"adding-methods",children:[]},{value:"Getting and Setting Class Properties",id:"getting-and-setting-class-properties",children:[]},{value:"Handling Methods That Take Multiple Types",id:"handling-methods-that-take-multiple-types",children:[]}]},{value:"Advanced Example",id:"advanced-example",children:[]}],o={rightToc:i},l="wrapper";function c(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,["components"]);return Object(a.b)(l,r({},o,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/neon-bindings/examples/tree/master/classes"}),"Examples")),Object(a.b)("p",null,"For now, reference this snippet, taken ",Object(a.b)("a",{href:"https://github.com/neon-bindings/neon/blob/master/test/dynamic/native/src/js/classes.rs",target:"_blank"},"from the tests:")),Object(a.b)("h2",{id:"basics"},"Basics"),Object(a.b)("p",null,"Let's create a simple struct that our class will use:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),"pub struct Employee {\n    // Rust struct properties map to JS class properties\n    id: i32,\n    name: String\n}\n")),Object(a.b)("p",null,"Now let's defines a custom JS class whose instances contain an Employee record. ",Object(a.b)("inlineCode",{parentName:"p"},"init")," is the constructor for the ",Object(a.b)("inlineCode",{parentName:"p"},"JsEmployee")," object. The methods that we define are prefixed with ",Object(a.b)("inlineCode",{parentName:"p"},"method"),". So if we want our JS object to have a method called ",Object(a.b)("inlineCode",{parentName:"p"},"alertUser"),", our method signature would be ",Object(a.b)("inlineCode",{parentName:"p"},"method alertUser(mut cx) {"),". All methods need to return types of the ",Object(a.b)("inlineCode",{parentName:"p"},"JsValue")," so we will need to ",Object(a.b)("inlineCode",{parentName:"p"},"upcast")," them. Because of this requirement, a method like the following would fail:"),Object(a.b)("p",null,"\u274c This will not work"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),'method talk(mut cx) {\n    Ok(cx.string("How are you doing?"))\n}\n')),Object(a.b)("p",null,"\u2705 But this will work:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),'method talk(mut cx) {\n    Ok(cx.string("How are you doing?").upcast())\n}\n')),Object(a.b)("h3",{id:"defining-the-constructor"},"Defining the ",Object(a.b)("inlineCode",{parentName:"h3"},"constructor")),Object(a.b)("p",null,"Now let's define our class. ",Object(a.b)("inlineCode",{parentName:"p"},"init")," will construct the class:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),'// --snip--\ndeclare_types! {\n    /// JS class wrapping Employee records.\n    pub class JsEmployee for Employee {\n        init(mut cx) {\n            let id = cx.argument::<JsNumber>(0)?.value();\n            let name: String = cx.argument::<JsString>(1)?.value();\n\n            Ok(Employee {\n                id: id as i32,\n                name: name,\n            })\n        }\n    }\n}\n\n// Export the class\nregister_module!(mut m, {\n    // <JsEmployee> tells neon what class we are exporting\n    // "Employee" is the name of the export that the class is exported as\n    m.export_class::<JsEmployee>("Employee")?;\n    Ok(())\n});\n')),Object(a.b)("h3",{id:"adding-methods"},"Adding Methods"),Object(a.b)("p",null,"Now let's add some methods to our class:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),'// --snip--\ninit(mut cx) {\n    let id = cx.argument::<JsNumber>(0)?.value();\n    let name: String = cx.argument::<JsString>(1)?.value();\n\n    Ok(Employee {\n        id: id as i32,\n        name: name,\n    })\n}\n\nmethod name(mut cx) {\n    let this = cx.this();\n    let name = {\n        let guard = cx.lock();\n        this.borrow(&guard).name\n    };\n    println!("{}", &name);\n    Ok(cx.undefined().upcast())\n}\n\nmethod greet(mut cx) {\n    let this = cx.this();\n    let msg = {\n        let guard = cx.lock();\n        let greeter = this.borrow(&guard);\n        format!("Hi {}!", greeter.name)\n    };\n    println!("{}", &msg);\n    Ok(cx.string(&msg).upcast())\n}\n\nmethod askQuestion(mut cx) {\n    println!("{}", "How are you?");\n    Ok(cx.undefined().upcast())\n}\n// --snip--\n')),Object(a.b)("p",null,"Then you can use instances of this type in JS just like any other object:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"const { Employee } = require('../native');\n\nconsole.log(new addon.Employee()); // fails: TypeError: not enough arguments\n\nconst john = new addon.Employee('John');\njohn.name(); // John\njohn.greet(); // Hi John!\njohn.askQuestion(); // How are you?\n")),Object(a.b)("p",null,"Since the methods on ",Object(a.b)("inlineCode",{parentName:"p"},"Employee")," expect this to have the right binary layout, they check to make sure that they aren\u2019t being called on an inappropriate object type. This means you can\u2019t segfault Node by doing something like:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"Employee.prototype.name.call({});\n")),Object(a.b)("p",null,"This safely throws a ",Object(a.b)("inlineCode",{parentName:"p"},"TypeError")," exception just like methods from other native classes like ",Object(a.b)("inlineCode",{parentName:"p"},"Date")," or ",Object(a.b)("inlineCode",{parentName:"p"},"Buffer")," do."),Object(a.b)("h3",{id:"getting-and-setting-class-properties"},"Getting and Setting Class Properties"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),'// --snip--\nlet this = cx.this();\n// Downcast the object so we can call .get and .set\nlet this = this.downcast::<JsObject>().or_throw(&mut cx)?;\nlet is_raining = this\n  .get(&mut cx, "raining")?\n  .downcast::<JsBoolean>().or_throw(&mut cx)?\n  .value();\nif is_raining {\n  let t = cx.boolean(false);\n  this.set(&mut cx, "shouldGoOutside", t)?;\n}\n// --snip--\n')),Object(a.b)("h3",{id:"handling-methods-that-take-multiple-types"},"Handling Methods That Take Multiple Types"),Object(a.b)("p",null,"Sometimes you may want your function to handle arguments that can be of multiple types. Here's an example showing just that:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),'// --snip--\nmethod introduce(mut cx) {\n    let name_or_age = cx.argument::<JsValue>(0)?;\n\n    if name_or_age.is_a::<JsString>() {\n        let name = name_or_age\n            .downcast::<JsString>()\n            .or_throw(&mut cx)?\n            .value();\n        println!("Hi, this is {}", name);\n    } else if name_or_age.is_a::<JsNumber>() {\n        let age = name_or_age\n            .downcast::<JsNumber>()\n            .or_throw(&mut cx)?\n            .value();\n        println!("Her birthday is on the {}th", age);\n    } else {\n        panic!("Name is not a string and age is not a number");\n    }\n\n    Ok(cx.undefined().upcast())\n}\n// --snip--\n')),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"const addon = require('../native');\n\nconst john = new addon.Employee(0, 'Lisa');\njohn.introduce('Mary'); // Hi, this is Mary\njohn.introduce(12); // Her birthday is on the 12th\n")),Object(a.b)("h2",{id:"advanced-example"},"Advanced Example"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),'#[macro_use]\nextern crate neon;\n\nuse neon::prelude::*;\n\npub struct User {\n    id: i32,\n    first_name: String,\n    last_name: String,\n    email: String,\n}\n\ntype Unit = ();\n\ndeclare_types! {\n  pub class JsUser for User {\n    init(mut cx) {\n      let id = cx.argument::<JsNumber>(0)?;\n      let first_name: Handle<JsString> = cx.argument::<JsString>(1)?;\n      let last_name: Handle<JsString> = cx.argument::<JsString>(2)?;\n      let email: Handle<JsString> = cx.argument::<JsString>(3)?;\n\n      Ok(User {\n        id: id.value() as i32,\n        first_name: first_name.value(),\n        last_name: last_name.value(),\n        email: email.value(),\n      })\n    }\n\n    method get(mut cx) {\n      let attr: String = cx.argument::<JsString>(0)?.value();\n\n      let this = cx.this();\n\n      match &attr[..] {\n        "id" => {\n          let id = {\n            let guard = cx.lock();\n            let user = this.borrow(&guard);\n            user.id\n          };\n          Ok(cx.number(id).upcast())\n        },\n        "first_name" => {\n          let first_name = {\n            let guard = cx.lock();\n            let user = this.borrow(&guard);\n            user.first_name.clone()\n          };\n          Ok(cx.string(&first_name).upcast())\n        },\n        "last_name" => {\n          let last_name = {\n            let guard = cx.lock();\n            let user = this.borrow(&guard);\n            user.last_name.clone()\n          };\n          Ok(cx.string(&last_name).upcast())\n        },\n        "email" => {\n          let email = {\n            let guard = cx.lock();\n            let user = this.borrow(&guard);\n            user.email.clone()\n          };\n          Ok(cx.string(&email).upcast())\n        },\n        _ => cx.throw_type_error("property does not exist")\n      }\n    }\n\n    method panic(_) {\n      panic!("User.prototype.panic")\n    }\n  }\n}\nregister_module!(mut m, {\n    m.export_class::<JsUser>("User")\n});\n')))}c.isMDXComponent=!0},217:function(e,n,t){"use strict";t.d(n,"a",(function(){return o})),t.d(n,"b",(function(){return p}));var a=t(0),r=t.n(a),s=r.a.createContext({}),i=function(e){var n=r.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},o=function(e){var n=i(e.components);return r.a.createElement(s.Provider,{value:n},e.children)};var l="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,o=e.parentName,l=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),u=i(t),p=a,m=u[o+"."+p]||u[p]||c[p]||s;return t?r.a.createElement(m,Object.assign({},{ref:n},l,{components:t})):r.a.createElement(m,Object.assign({},{ref:n},l))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,i=new Array(s);i[0]=u;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o[l]="string"==typeof e?e:a,i[1]=o;for(var p=2;p<s;p++)i[p]=t[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);