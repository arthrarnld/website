(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{207:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"rightToc",(function(){return i})),t.d(n,"default",(function(){return p}));t(58),t(31),t(21),t(22),t(59),t(0);var a=t(217);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var c={id:"type-checking",title:"Type Checking",sidebar_label:"Type Checking"},i=[{value:"Upcasting",id:"upcasting",children:[]},{value:"Downcasting",id:"downcasting",children:[]},{value:"Checking Types",id:"checking-types",children:[]}],o={rightToc:i},s="wrapper";function p(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,["components"]);return Object(a.b)(s,r({},o,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"If we can declare functions with Rust that can be called from JS then we need to know the type of the argument that was passed to the argument in order to work with in Rust. This is where casting comes into play. ",Object(a.b)("strong",{parentName:"p"},"Upcasting")," makes a type less specific while ",Object(a.b)("strong",{parentName:"p"},"Downcasting")," makes a type more specific. A ",Object(a.b)("inlineCode",{parentName:"p"},"JsValue"),", which represents an arbitrary JS value that we do not know the type of. We can cast this value to something more specific like a ",Object(a.b)("inlineCode",{parentName:"p"},"JsNumber")," so that we can use it in Rust as if it were a number. Downcasting use useful when we want to pass values back to the JS engine. See the ",Object(a.b)("a",r({parentName:"p"},{href:"/docs/classes"}),"classes section")," for more on this."),Object(a.b)("h2",{id:"upcasting"},"Upcasting"),Object(a.b)("p",null,"Every method of a JS class implicity returns a ",Object(a.b)("inlineCode",{parentName:"p"},"JsValue"),". No type more or less specific than a ",Object(a.b)("inlineCode",{parentName:"p"},"JsValue")," can be returned."),Object(a.b)("p",null,"For example, the following class method would fail to compile:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),'declare_types! {\n    /// JS class wrapping Employee records.\n    pub class JsEmployee for Employee {\n        method talk(mut cx) {\n            Ok(cx.string("Hello").upcast())\n        }\n    }\n}\n')),Object(a.b)("p",null,"Safely upcast a handle to a supertype.\nThis method does not require an execution context because it only copies a handle."),Object(a.b)("h2",{id:"downcasting"},"Downcasting"),Object(a.b)("p",null,"Attempts to downcast a handle to another type, which may fail. A failure to downcast does not throw a JavaScript exception, so it's OK to continue interacting with the JS engine if this method produces an ",Object(a.b)("inlineCode",{parentName:"p"},"Err")," result."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),"// --snip\ncx.number(17).downcast();\ncx.number(17).downcast_or_throw();\n// --snip--\n")),Object(a.b)("h2",{id:"checking-types"},"Checking Types"),Object(a.b)("p",null,"Test whether this value is an instance of the given type."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-rust"}),"// --snip--\nlet v: Handle<JsValue> = cx.number(17).upcast();\nv.is_a::<JsString>(); // false\nv.is_a::<JsNumber>(); // true\nv.is_a::<JsValue>();  // true\n// --snip--\n")))}p.isMDXComponent=!0},217:function(e,n,t){"use strict";t.d(n,"a",(function(){return o})),t.d(n,"b",(function(){return u}));var a=t(0),r=t.n(a),c=r.a.createContext({}),i=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},o=function(e){var n=i(e.components);return r.a.createElement(c.Provider,{value:n},e.children)};var s="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},l=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,c=e.originalType,o=e.parentName,s=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),l=i(t),u=a,b=l[o+"."+u]||l[u]||p[u]||c;return t?r.a.createElement(b,Object.assign({},{ref:n},s,{components:t})):r.a.createElement(b,Object.assign({},{ref:n},s))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var c=t.length,i=new Array(c);i[0]=l;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[s]="string"==typeof e?e:a,i[1]=o;for(var u=2;u<c;u++)i[u]=t[u];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}l.displayName="MDXCreateElement"}}]);