<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Word Counting · Neon</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="In this guide we&#x27;re going to recreate the [word counting demo Dave Herman gave in his talk about neon](https://youtu.be/jINMIAicaS0?t=789)."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Word Counting · Neon"/><meta property="og:type" content="website"/><meta property="og:url" content="https://neon-bindings.com/"/><meta property="og:description" content="In this guide we&#x27;re going to recreate the [word counting demo Dave Herman gave in his talk about neon](https://youtu.be/jINMIAicaS0?t=789)."/><meta property="og:image" content="https://neon-bindings.com/logo/text-logo.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://neon-bindings.com/logo/text-logo.svg"/><link rel="shortcut icon" href="/logo/letter-logo.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css"/><link rel="alternate" type="application/atom+xml" href="https://neon-bindings.com/blog/atom.xml" title="Neon Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://neon-bindings.com/blog/feed.xml" title="Neon Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-130626950-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/logo/text-logo.svg" alt="Neon"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/intro" target="_self">Docs</a></li><li class=""><a href="https://github.com/neon-bindings/examples#table-of-contents" target="_self">Examples</a></li><li class=""><a href="/api/neon/" target="_self">API</a></li><li class=""><a href="/docs/learning-resources" target="_self">Resources</a></li><li class=""><a href="/docs/roadmap" target="_self">Roadmap</a></li><li class=""><a href="/help" target="_self">Help</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="https://github.com/neon-bindings/neon" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/neon-bindings/website/blob/master/docs/word-counting-example.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Word Counting</h1></header><article><div><span><p>In this guide we're going to recreate the <a href="https://youtu.be/jINMIAicaS0?t=789">word counting demo Dave Herman gave in his talk about neon</a>.</p>
<p>First start by creating a new project with <code>neon-cli</code>:</p>
<pre><code class="hljs css language-bash">neon new hello
<span class="hljs-built_in">cd</span> hello
npm install <span class="hljs-comment"># OR `yarn install`</span>
node -e <span class="hljs-string">'require("./")'</span>
</code></pre>
<p>When installing the dependencies, npm will run <code>neon build --release</code> and build a release build of our code in <code>./native</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="i-take-thee-at-thy-word"></a><a href="#i-take-thee-at-thy-word" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>I Take Thee at thy Word</h2>
<p>To illustrate what you can do with Neon, we will a little word counting demo. The demo is simple: read in the complete plays of Shakespeare and count the total number of occurrences of the word “thee”. First lets implement this demo in pure JS. The top-level code splits the corpus into lines, and sums up the counts for each line:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span>(<span class="hljs-params">corpus, search</span>) </span>{
  <span class="hljs-keyword">const</span> ls = lines(corpus);
  <span class="hljs-keyword">const</span> total = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, n = ls.length; i &lt; n; i++) {
    total += wcLine(ls[i], search);
  }
  <span class="hljs-keyword">return</span> total;
}
</code></pre>
<p>Searching an individual line involves splitting the line up into word and matching each word against the search string:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wcLine</span>(<span class="hljs-params">line, search</span>) </span>{
  <span class="hljs-keyword">const</span> words = line.split(<span class="hljs-string">' '</span>);
  <span class="hljs-keyword">const</span> total = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, n = words.length; i &lt; n; i++) {
    <span class="hljs-keyword">if</span> (matches(words[i], search)) {
      total++;
    }
  }
  <span class="hljs-keyword">return</span> total;
}
</code></pre>
<p>The rest of the details are pretty straightforward but definitely check out the code—it’s small and self-contained.</p>
<h2><a class="anchor" aria-hidden="true" id="fall-into-our-rustic-revelry"></a><a href="#fall-into-our-rustic-revelry" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fall Into our Rustic Revelry</h2>
<p>One of the amazing things about Rust is that highly efficient code can still be remarkably compact and readable. In the Rust version of the algorithm, the code for summing up the counts for all the lines looks pretty similar to the JS code:</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> total = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> line.split(<span class="hljs-string">' '</span>) {
    <span class="hljs-keyword">if</span> matches(word, search) {
        total += <span class="hljs-number">1</span>;
    }
}
total <span class="hljs-comment">// in Rust you can omit `return` for a trailing expression</span>
</code></pre>
<p>In fact, that same code can be written at a higher level of abstraction without losing performance, using iteration methods like filter and fold (similar to Array.prototype.filter and Array.prototype.reduce in JS):</p>
<pre><code class="hljs css language-rust">line.split(<span class="hljs-string">' '</span>)
    .filter(|word| matches(word, search))
    .fold(<span class="hljs-number">0</span>, |sum, _| sum + <span class="hljs-number">1</span>)
</code></pre>
<p>In my quick experiments, that even seems to shave a few milliseconds off the total running time. I think this is a nice demonstration of the power of Rust’s zero-cost abstractions, where idiomatic and high-level abstractions produce the same or sometimes even better performance (by making additional optimizations possible, like eliminating bounds checks) than lower-level, more obscure code.</p>
<p>On my machine, the simple Rust translation runs in about 80 – 85ms. Not bad—about 3x as fast just from using Rust, and in roughly the same number of lines of code (60 in JS, 70 in Rust). By the way, I’m being approximate here with the numbers, because this isn’t a remotely scientific benchmark. My goal is just to demonstrate that you can get significant performance improvements from using Rust; in any given situation, the particular details will of course matter.</p>
<h2><a class="anchor" aria-hidden="true" id="their-thread-of-life-is-spun"></a><a href="#their-thread-of-life-is-spun" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Their Thread of Life is Spun</h2>
<p>We’re not done yet, though! Rust enables something even cooler for Node: we can easily and safely parallelize this code—and I mean without the night-sweats and palpitations usually associated with multithreading. Here’s a quick look at the top level logic in the Rust implementation of the demo:</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">let</span> total = cx.borrow(&amp;buffer, |data| {
    <span class="hljs-keyword">let</span> corpus = <span class="hljs-built_in">str</span>::from_utf8(data.as_slice()).ok().unwrap();
    wc_parallel(&amp;lines(corpus), search)
});
</code></pre>
<p>The <code>cx.borrow</code> API lets Neon safely expose the raw bytes of a Node Buffer object (i.e., a typed array) to Rust threads, by preventing JS from running in the meantime. And Rust’s concurrency model makes programming with threads actually fun.</p>
<p>To demonstrate how easy this can be, I used Niko Matsakis’s new Rayon crate of beautiful data parallelism abstractions. Changing the demo to use Rayon is as simple as replacing the into_iter/map/fold/ lines above with:</p>
<pre><code class="hljs css language-diff"><span class="hljs-addition">+   lines.into_par_iter()</span>
      .map(|line| wc_line(line, search))
      .sum()
</code></pre>
<p>Keep in mind, Rayon wasn’t designed with Neon in mind—its generic primitives match the iteration protocols of Rust, so Neon was able to just pull it off the shelf.</p>
<p>With that simple change, on my two-core MacBook Air, the demo goes from about 85ms down to about 50ms.</p>
<h2><a class="anchor" aria-hidden="true" id="bridge-most-valiantly-with-excellent-discipline"></a><a href="#bridge-most-valiantly-with-excellent-discipline" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bridge Most Valiantly, with Excellent Discipline</h2>
<p>I’ve worked on making the integration as seamless as possible. From the Rust side, Neon functions follow a simple protocol, taking a Call object and returning a JavaScript value:</p>
<pre><code class="hljs css language-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">search</span></span>(<span class="hljs-keyword">mut</span> cx: FunctionContext) -&gt; JsResult&lt;JsNumber&gt; {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-literal">Ok</span>(cx.number(total))
}
</code></pre>
<p><code>cx</code>, a <code>FunctionContext</code> struct, safely tracks handles into V8’s garbage-collected heap. The Neon API uses the Rust type system to guarantee that your native module can’t crash your app by mismanaging object handles.</p>
<p>From the JS side, loading the native module is straightforward:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> myNeonModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">'neon-bridge'</span>).load();
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="wherefores-this-noise"></a><a href="#wherefores-this-noise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wherefore’s this Noise?</h2>
<p>I hope this demo is enough to get people interested. Beyond the sheer fun of it, I think the strongest reasons for using Rust in Node are performance and parallelism. As the Rust ecosystem grows, it’ll also be a way to give Node access to cool Rust libraries. Beyond that, I’m hoping that Neon can make a nice abstraction layer that just makes writing native Node modules less painful. With projects like node-uwp it might even be worth exploring evolving Neon towards a JS-engine-agnostic abstraction layer.</p>
<p>There are lots of possibilities, but I need help! If you want to get involved, I’ve created a community slack (grab an invite from the Slackin app) and a #neon IRC channel on Mozilla IRC (irc.mozilla.org).</p>
<h2><a class="anchor" aria-hidden="true" id="source"></a><a href="#source" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Source</h2>
<p>Here is the <a href="https://github.com/neon-bindings/examples/tree/master/word-counting">source code</a> for this guide.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#i-take-thee-at-thy-word">I Take Thee at thy Word</a></li><li><a href="#fall-into-our-rustic-revelry">Fall Into our Rustic Revelry</a></li><li><a href="#their-thread-of-life-is-spun">Their Thread of Life is Spun</a></li><li><a href="#bridge-most-valiantly-with-excellent-discipline">Bridge Most Valiantly, with Excellent Discipline</a></li><li><a href="#wherefores-this-noise">Wherefore’s this Noise?</a></li><li><a href="#source">Source</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/logo/text-logo.svg" alt="Neon" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/getting-started.html">Getting Started</a><a href="https://github.com/neon-bindings/examples">Examples</a><a href="https://neon-bindings.com/api/neon/index.html" target="_blank">API Reference</a></div><div><h5>Community</h5><a href="/users.html">User Showcase</a><a href="https://rust-bindings-slackin.herokuapp.com/">Project Chat</a><a href="https://twitter.com/rustneon" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/neon-bindings/neon">GitHub</a><a class="github-button" href="https://github.com/neon-bindings/neon" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 Neon Bindings</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'bfa6bb4b57d4fa853c0358ee9b195146',
                indexName: 'amilajack_neon',
                inputSelector: '#search_input_react'
              });
            </script></body></html>